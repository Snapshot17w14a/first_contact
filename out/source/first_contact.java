/* autogenerated by Processing revision 1293 on 2023-12-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class first_contact extends PApplet {



enum GameState{Scenes, PipeGame, JarGame, StoryScreen, MainMenu, WinMenu, DeathMenu};

//Framework Variables
GameState gameState = GameState.MainMenu;
SceneManager sceneManager;
Cake cake;
Scene currentScene;
Scene basementScene;
Scene hallwayScene;
Scene kitchenScene;
Scene storageScene;
Scene jarHint;
Scene pipeHint;
Scene kitchenHint;
PImage basementScatteredBackground;
PImage basementCompletedBackground;
PImage hallwayBackground;
PImage kitchenBackground;
PImage storageBackground;
PImage winBackground;
PImage mainMenuBackground;
PImage jarHintBackground;
PImage pipeHintBackground;
PImage kitchenHintBackground;
PImage deathBackground;
PImage jarGameBackground;
PImage magnifier;
PImage keyImage;
PImage bowl;
PImage fullBowlImage;
PImage jarHintPaper;
PImage pipeHintPaper;
PImage kitchenHintPaper;
PImage ovenHeat;
PImage inventoryImage;
PImage lockedDoorImage;
PImage[] cookGameItems = new PImage[5];
Inventory inventory;
Item glass;
Item fullBowl;
Item pipeKey;
Item cookKey;
Item jarKey;
Item[] cookItems = new Item[5];
TextBox hallwayWoodBeam;
TextBox fullInventoryNotification;
TextBox keysMissing;
TextBox missingIngredients;
TextBox missingBowl;
TextBox cleanerTextbox;
TextBox pipeTextBox;
TextBox cookKeyFound;
SoundFile mainMenuMusic;
SoundFile gameMusic;
SoundFile grabObject;
SoundFile mainDoorUnlock;
SoundFile pipeGameVictory;
SoundFile correctChime;
SoundFile pipeSound;
SoundFile keysPickup;
SoundFile lockedDoor;
SoundFile whisper;
SoundFile click;
SoundFile notePickup;
SoundFile ovenFinished;
SoundFile[] jarSlides = new SoundFile[2];
SoundFile[] roomTransitions = new SoundFile[3];
boolean isHowToPlay = false;
boolean isWinMenu = false;
boolean isMainMenuLooped = false;
boolean isgameMusicLooped = false;
boolean isStoryScreen = false;
boolean isGameplayTimerSet = false;
int gameplaySeconds = 300;
int gameEndMilliseconds;

//PipeGame Variables
int gridWidth = 5;
int gridHeight = 3;
int usedLayout;
static int gridBoxSize = 145;
ArrayList<PipeHolder> pipeHolders = new ArrayList<PipeHolder>();
PImage pipeGameBackground;
PImage straightPipeUpDown;
PImage straightPipeLeftRight;
PImage[] straightPipeImages = new PImage[2];
PImage[] cornerPipeImages = new PImage[4];
int[][] pipeLayouts = {{1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0}, {0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1}};
int[][] pipeSolutions = {{5, 1, -1, 0, 1, -1, 4, 0, 2, 4, -1, 3, 2, -1, 3}, {1, 0, 5, 5, 1, 4, 4, -1, 0, 2, 3, 2, -1, 3, 5}};
int[] correctCountAmount = {11, 13};
boolean isPipeGameOver = false;

//JarGame Variables
int jarCount = 5;
Jar[] correctJarOrder;
Jar[] randomJarOrder;
Jar selectedJar;
boolean allowClick = true;
boolean isJarAvailable = false;
boolean isJarGameOver = false;
JarButton moveLeft;
JarButton moveRight;
PImage jarArrowLeft;
PImage jarArrowRight;
PImage jarArrowUp;
PImage jarArrowDown;
PImage[] jarImages = new PImage[5];

//Universal Variables
int targetMilliseconds;
boolean allowMouseClick = true;
boolean isDelaySet = false;
PFont baseFont;
PFont titleFont;

//Menu Variables
PVector playButtonPosition = new PVector(715, 400);
PVector howToButtonPosition = new PVector(750, 490);
PVector backButtonPosition = new PVector(900, 540);
PVector mainmenuButtonPosition = new PVector(400, 550);
PVector quitButtonPosition = new PVector(600, 550);

//String Variables
String blockedWay = "The pathway to the top floor seems to be blocked by a huge wooden beam!";
String fullInventory = "The burden of carrying this would be too much for your fragile soul.";
String keysText = "You have not found all the keys requiered to free your soul, go search for them before the clock hits 8am!";
String missingIngredientsText = "You do not have any ingredients to put in the bowl at this moment!";
String missingBowlText = "You do not have anything on you that needs cooking.";
String cookKeyText = "While preparing the cake for you long lost shef friend you notice a key hanging from the heatin element of the oven.";
String cleanerKeyPosition = "Cleaner's soul:\nThank you for organizing those jars my friend, it has been bothering my soul for a century. One of the keys for the main door is in the basket next to the winerack.";
String pipeText = "After connecting the pipes you notice that the waterflow pushed a key out of the drain pipe.";
String[] introText;

public void setup()
{
    /* size commented out by preprocessor */;
    //Load Music
    mainMenuMusic = new SoundFile(this, "Title_screen_soundtrack.wav");
    gameMusic = new SoundFile(this, "Soundtrack_v.3.wav");
    grabObject = new SoundFile(this, "grabbing_object.wav");
    mainDoorUnlock = new SoundFile(this, "door_unlock.wav");
    pipeGameVictory = new SoundFile(this, "water_puzzle_complete.wav");
    correctChime = new SoundFile(this, "correct_chime.wav");
    pipeSound = new SoundFile(this, "pipeRotating.wav");
    keysPickup = new SoundFile(this, "keys_pickup.wav");
    lockedDoor = new SoundFile(this, "Locked_door.wav");
    whisper = new SoundFile(this, "ghostWhisper.wav");
    click = new SoundFile(this, "click.wav");
    notePickup = new SoundFile(this, "notePickup.wav");
    ovenFinished = new SoundFile(this, "ovenFinished.wav");
    jarSlides[0] = new SoundFile (this, "jarSlide1.wav");
    jarSlides[1] = new SoundFile (this, "jarSlide2.wav");
    roomTransitions[0] = new SoundFile(this, "door_1.wav");
    roomTransitions[1] = new SoundFile(this, "door_2.wav");
    roomTransitions[2] = new SoundFile(this, "door_3.wav");

    //Load fonts
    baseFont = createFont("monbaiti.ttf", 24);
    titleFont = createFont("lucindablack.ttf", 96);

    //Load .txt-s
    introText = loadStrings("introtext.txt");
    
    //Background images
    basementScatteredBackground = loadImage("BasementScattered.png");
    basementCompletedBackground = loadImage("BasementCompleted.png");
    hallwayBackground = loadImage("hallwayBackground.png");
    kitchenBackground = loadImage("kitchenBackground.png");
    storageBackground = loadImage("storageBackground.png");
    mainMenuBackground = loadImage("mainMenu.png");
    jarHintBackground = loadImage("jarHintBackground.png");
    pipeHintBackground = loadImage("pipeHintBackground.png");
    kitchenHintBackground = loadImage("kitchenHintBackground.png");
    deathBackground = loadImage("deathBackground.png");
    jarGameBackground = loadImage("jarGameBackground.png");

    //Item images
    kitchenHintPaper = loadImage("kitchenHint.png");
    jarHintPaper = loadImage("jarHint.png");
    pipeHintPaper = loadImage("pipeHint.png");
    ovenHeat = loadImage("oven.png");
    magnifier = loadImage("magnifyingGlass.png");
    keyImage = loadImage("key.png");
    bowl = loadImage("bowl.png");
    fullBowlImage = loadImage("fullBowlItem.png");
    inventoryImage = loadImage("inventory.png");
    lockedDoorImage = loadImage("lockedDoor.png");
    cookGameItems[0] = loadImage("water.png");
    cookGameItems[1] = loadImage("honey.png");
    cookGameItems[2] = loadImage("flour.png");
    cookGameItems[3] = loadImage("bakingPowder.png");
    cookGameItems[4] = loadImage("sugar.png");


    //PipeGame images
    pipeGameBackground = loadImage("pipeBackground.png");
    straightPipeImages[0] = loadImage("pipeUpDown.png");
    straightPipeImages[1] = loadImage("pipeLeftRight.png");
    cornerPipeImages[0] = loadImage("pipeSouthEast.png");
    cornerPipeImages[1] = loadImage("pipeSouthWest.png");
    cornerPipeImages[2] = loadImage("pipeNorthEast.png");
    cornerPipeImages[3] = loadImage("pipeNorthWest.png");

    //JarGame images
    jarArrowLeft = loadImage("left_arrow.png");
    jarArrowRight = loadImage("right_arrow.png");
    jarArrowUp = loadImage("upArrow.png");
    jarArrowDown = loadImage("downArrow.png");
    jarImages[0] = loadImage("jar5.png");
    jarImages[1] = loadImage("jar4.png");
    jarImages[2] = loadImage("jar3.png");
    jarImages[3] = loadImage("jar2.png");
    jarImages[4] = loadImage("jar1.png");

    //SceneManager initialization
    sceneManager = new SceneManager();

    //Inventory initializatiob
    inventory = new Inventory(3, 100, 10);
    fullInventoryNotification = new TextBox(fullInventory, currentScene);

    //Item initialization
    glass = new Item(magnifier);
    pipeKey = new Item(keyImage);
    cookKey = new Item(keyImage);
    jarKey = new Item(keyImage);
    fullBowl = new Item(fullBowlImage);
    cookItems[0] = new Item(cookGameItems[0]);
    cookItems[1] = new Item(cookGameItems[1]);
    cookItems[2] = new Item(cookGameItems[2]);
    cookItems[3] = new Item(cookGameItems[3]);
    cookItems[4] = new Item(cookGameItems[4]);

    //Scene initialization
    basementScene = new Scene(basementScatteredBackground);
    hallwayScene = new Scene(hallwayBackground);
    kitchenScene = new Scene(kitchenBackground);
    storageScene = new Scene(storageBackground);
    kitchenHint = new Scene(kitchenHintBackground, true, kitchenScene);
    jarHint = new Scene(jarHintBackground, true, GameState.JarGame);
    pipeHint = new Scene(pipeHintBackground, true, GameState.PipeGame);

    //TextBox initialization
    pipeTextBox = basementScene.createTextBox(pipeText);
    hallwayWoodBeam = hallwayScene.createTextBox(blockedWay);
    keysMissing = hallwayScene.createTextBox(keysText);
    missingIngredients = kitchenScene.createTextBox(missingIngredientsText);
    missingBowl = kitchenScene.createTextBox(missingBowlText);
    cleanerTextbox = storageScene.createTextBox(cleanerKeyPosition);
    cookKeyFound = kitchenScene.createTextBox(cookKeyText);

    //Move button initialization
    basementScene.addMoveButton(new PVector(358, 128), new PVector(48, 48), hallwayScene, jarArrowUp);
    basementScene.addMoveButton(new PVector(455, 225), new PVector(64, 64), pipeHint, pipeHintPaper, notePickup);
    hallwayScene.addMoveButton(new PVector(490, 530), new PVector(48, 48), basementScene, jarArrowDown);
    hallwayScene.addMoveButton(new PVector(769, 257), new PVector(48, 48), kitchenScene, jarArrowRight);
    hallwayScene.addMoveButton(new PVector(418, 252), new PVector(48, 48), storageScene, jarArrowLeft);
    hallwayScene.addExitButton(new PVector(524, 251), new PVector(64, 64), lockedDoorImage);
    kitchenScene.addMoveButton(new PVector(155, 281), new PVector(48, 48), hallwayScene, jarArrowLeft);
    kitchenScene.addMoveButton(new PVector(270, 373), new PVector(64, 64), kitchenHint, kitchenHintPaper, notePickup);
    storageScene.addMoveButton(new PVector(width/2, 550), new PVector(48, 48), hallwayScene, jarArrowDown);
    storageScene.addMoveButton(new PVector(285, 354), new PVector(64, 64), jarHint, jarHintPaper, notePickup);
    cake = new Cake(new PVector(359, 250), new PVector(64, 64), bowl, kitchenScene.sceneButtons);
    kitchenScene.sceneButtons.add(cake);

    //Cook game initialization
    cake.itemsNeeded = cookItems;
    kitchenScene.sceneButtons.add(new Oven(new PVector(576, 317), new PVector(80, 64), ovenHeat));
    hideIngredients();

    //Text button initialization
    hallwayScene.addTextButton(new PVector(168, 192), new PVector(64, 64), magnifier, hallwayWoodBeam);

    //Load first scene
    sceneManager.currentScene = basementScene;
    fullInventoryNotification.parentScene = basementScene;
    basementScene.sceneTexts.add(fullInventoryNotification);

    //Pipe Game initialization
    for(int rows = 0; rows < gridHeight; rows++)
    {
        int yPos = 170 + (gridBoxSize * rows);
        for(int column = 0; column < gridWidth; column++)
        {
            int xPos = 220 + (gridBoxSize * column);
            pipeHolders.add(new PipeHolder(new PVector(xPos, yPos)));
        }
    }
    usedLayout = (int)(random(0, 2));
    for(int i = 0; i < pipeHolders.size(); i++)
    {
        PipeHolder pH = pipeHolders.get(i);
        switch(pipeLayouts[usedLayout][i])
        {
            case 0:
                pH.heldPipe = new CornerPipe(pH.position, (int)(random(0, 4)), i, cornerPipeImages);
                break;
            case 1:
                pH.heldPipe = new StraightPipe(pH.position, (int)(random(4, 6)), i, straightPipeImages);
                break;
        }
    }

    //JarGame Initialization
    correctJarOrder = new Jar[jarCount];
    randomJarOrder = new Jar[jarCount];
    for(int i = 0; i < jarCount; i++) correctJarOrder[i] = new Jar(new PVector(200, 200), i, jarImages[i]);
    for(int i = 0; i < jarCount; i++) scrambleJars(i);
    moveRight = new JarButton(jarArrowRight, new PVector(700, 500));
    moveLeft = new JarButton(jarArrowLeft, new PVector(300, 500));
    selectedJar = null;
}

public void draw() 
{
    background(0);
    if(isGameplayTimerSet && millis() >= gameEndMilliseconds) 
    {
        gameState = GameState.DeathMenu;
        isGameplayTimerSet = false;
        resetGame();
        return;
    }
    switch(gameState)
    {
        case Scenes:
            drawScenes();
            fill(0xFF2FAD87);
            textAlign(RIGHT, CENTER);
            textFont(baseFont, 24);
            if(!(millis() >= gameEndMilliseconds)) text("Seconds left until daytime: " + (int)((gameEndMilliseconds - millis()) / 1000), 980, 20);
            return;
        case PipeGame:
            pipeGame();
            return;
        case JarGame:
            jarGame();
            return;
        case MainMenu:
            mainMenu();
            return;
        case WinMenu:
            winMenu();
            return;
        case StoryScreen:
            storyScreen();
            return;
        case DeathMenu:
            deathMenu();
            return;
    }
}

//Mouse click handling
public void mousePressed() 
{
    if(allowMouseClick)
    {
        switch(gameState)
        {
            case Scenes:
                sceneManager.mouseClick();
                break;
            case PipeGame:
                if(mouseX < 975 && mouseX > 925 && mouseY < 575 && mouseY > 525) {sceneManager.loadScene(basementScene); gameState = GameState.Scenes;}
                for(PipeHolder pH : pipeHolders)
                {
                    if(pH.isOverHeldPipe() && !isPipeGameOver)
                    {
                        pH.heldPipe.rotatePipe();
                    }
                }
                break;
            case JarGame:
                if(mouseX < 975 && mouseX > 925 && mouseY < 575 && mouseY > 525) {sceneManager.loadScene(storageScene); gameState = GameState.Scenes;}
                else if(!isJarGameOver)
                {
                    if(isJarAvailable && moveRight.isOverJarButton()) {moveRight.moveRight(selectedJar.jarPosition);}
                    else if(isJarAvailable && moveLeft.isOverJarButton()) {moveLeft.moveLeft(selectedJar.jarPosition);}
                    else if(isJarAvailable) {selectedJar.isJarSelected = false; selectedJar = null;}
                    else 
                    {
                        for(Jar jar : correctJarOrder)
                        {
                            if(jar.isOverJar())
                            {
                                selectedJar = jar;
                                jar.isJarSelected = true;
                            }
                        }
                    }
                }
                break;
            case MainMenu:
            case WinMenu:
            case StoryScreen:
            case DeathMenu:
                checkMenuClick();
                break;
        }
    }
    allowMouseClick = false;
}
public void mouseReleased()
{
    allowMouseClick = true;
}

//PxC gameloop
public void drawScenes()
{
    sceneManager.draw();
    inventory.drawInventory();
}

//PipeGame gameloop
public void pipeGame()
{
    int correctCount = 0;
    background(pipeGameBackground);
    rectMode(CENTER);
    fill(255, 0, 0, 128);
    strokeWeight(4);
    rect(950, 550, 50, 50);
    imageMode(CENTER);
    image(jarArrowDown, 950, 550, 40, 40);
    imageMode(CORNER);
    for(PipeHolder pHolder : pipeHolders) pHolder.drawHolder();
    for(int i = 0; i < pipeHolders.size(); i++)
    {
        PipeHolder pHolder = pipeHolders.get(i);
        if(pipeSolutions[usedLayout][i] != -1 && pipeSolutions[usedLayout][i] == pHolder.heldPipe.pipeRotationNum) correctCount++;
    }
    if(correctCount == correctCountAmount[usedLayout])
    {
        isPipeGameOver = true;
        if(!isDelaySet) {setupDelay((int)(pipeGameVictory.duration())); pipeGameVictory.play(); correctChime.play();}
        else if(isDelayOver())
        {
            sceneManager.loadScene(basementScene);
            gameState = GameState.Scenes;
            basementScene.sceneButtons.remove(1);
            isDelaySet = false;
            basementScene.addItemButton(new PVector(753, 319), new PVector(64, 64), pipeKey, true);
            pipeTextBox.toggleRender();
            basementScene.background = basementCompletedBackground;
        }
    }
}

//JarGame gameloop
public void jarGame()
{
    background(jarGameBackground);
    rectMode(CENTER);
    fill(255, 0, 0, 128);
    strokeWeight(4);
    rect(950, 550, 50, 50);
    imageMode(CENTER);
    image(jarArrowDown, 950, 550, 40, 40);
    imageMode(CORNER);
    for(Jar jar : correctJarOrder) jar.drawJar();
    if(selectedJar != null)
    {
        isJarAvailable = true;
        moveRight.drawArrow();
        moveLeft.drawArrow();
    }
    else isJarAvailable = false;
    int correctCount = 0;
    for(Jar jar : correctJarOrder) if(jar.isInCorrectSpot == true) correctCount++;
    if(correctCount == 5)
    {
        isJarGameOver = true;
        selectedJar = null;
        if(!isDelaySet) {setupDelay(1); correctChime.play();}
        if(isDelayOver())
        {
            sceneManager.loadScene(storageScene);
            gameState = GameState.Scenes;
            storageScene.sceneButtons.remove(1);
            isDelaySet = false;
            storageScene.addItemButton(new PVector(553, 465), new PVector(64, 64), jarKey, true);
            cleanerTextbox.toggleRender();
            whisper.play();
        }
    }
}

public void scrambleJars(int index)
{
    int correctArrayIndex = index;
    int randomArrayIndex;
    do{randomArrayIndex = (int)(random(0, jarCount));}
    while(randomJarOrder[randomArrayIndex] != null);
    randomJarOrder[randomArrayIndex] = correctJarOrder[correctArrayIndex];
    randomJarOrder[randomArrayIndex].jarPosition = randomArrayIndex;
}


public void checkMenuClick()
{
    switch(gameState)
    {
        case StoryScreen:
            gameState = GameState.Scenes;
            startGameplayTimer();
            mainMenuMusic.stop();
            isMainMenuLooped = false;
            gameMusic.loop();
            break;
        case MainMenu:
            if(isHowToPlay && mouseX < backButtonPosition.x + 100/2 && mouseX > backButtonPosition.x - 100/2 && mouseY < backButtonPosition.y + 50/2 && mouseY > backButtonPosition.y - 50/2) isHowToPlay = false;
            else if(!isHowToPlay && mouseX < playButtonPosition.x + 250/2 && mouseX > playButtonPosition.x - 250/2 && mouseY < playButtonPosition.y + 70/2 && mouseY > playButtonPosition.y - 70/2) 
            {
                gameState = GameState.StoryScreen;
                isStoryScreen = true;
            }
            else if(!isHowToPlay && mouseX < howToButtonPosition.x + 150/2 && mouseX > howToButtonPosition.x - 150/2 && mouseY < howToButtonPosition.y + 50/2 && mouseY > howToButtonPosition.y - 50/2) isHowToPlay = true;
            break;
        case WinMenu:
            if(mouseX < mainmenuButtonPosition.x + 180/2 && mouseX > mainmenuButtonPosition.x - 180/2 && mouseY < mainmenuButtonPosition.y + 50/2 && mouseY > mainmenuButtonPosition.y - 50/2)
            {
                resetGame();
                gameState = GameState.MainMenu;
                isWinMenu = false;
            }
            else if(mouseX < quitButtonPosition.x + 180/2 && mouseX > quitButtonPosition.x - 180/2 && mouseY < quitButtonPosition.y + 50/2 && mouseY > quitButtonPosition.y - 50/2) exit();
            break;
        case DeathMenu:
            resetGame();
            gameState = GameState.MainMenu;
            break;
    }
}

//Main Menu logic
public void mainMenu()
{
    if(!isMainMenuLooped) {isMainMenuLooped = true; mainMenuMusic.loop();}
    imageMode(CENTER);
    background(mainMenuBackground);
    strokeWeight(2);
    fill(0xFFFF0000);
    rectMode(CENTER);
    if(!isHowToPlay)
    {
        rect(playButtonPosition.x, playButtonPosition.y, 250, 70, 10);
        fill(0xFF00FF00);
        rect(howToButtonPosition.x, howToButtonPosition.y, 150, 50, 5);
        textAlign(CENTER, CENTER);
        textFont(baseFont, 36);
        fill(0xFF000000);
        text("Play", playButtonPosition.x, playButtonPosition.y);
        textFont(baseFont, 24);
        text("How to play", howToButtonPosition.x, howToButtonPosition.y);
        textAlign(LEFT, CENTER);
        textFont(titleFont, 94);
        text("Phantom Liberation", 20, 160);
        fill(0xFFFF0000);
        text("Phantom Liberation", 16, 156);
    }
    else
    {
        rect(backButtonPosition.x, backButtonPosition.y, 100, 50, 5);
        fill(0xFF000000);
        textAlign(CENTER, CENTER);
        textFont(baseFont, 24);
        text("Back", backButtonPosition.x, backButtonPosition.y);
        textAlign(LEFT, CENTER);
        textFont(titleFont, 36);
        text("Phantom Liberation", 20, 40);
        fill(0xFFFF0000);
        text("Phantom Liberation", 18, 38);
        fill(128, 128, 128, 196);
        rect(width/2, height/2, 900, 400);
        textAlign(LEFT, TOP);
        fill(0);
        textFont(baseFont, 24);
        text("Try to walk trough the areas by clicking on the arrows indicating the locations.\n\nSearch for the keys within the puzzles that are hidden throughout the mansion.\n\nOnce you have collected all 3 keys you can exit through the front door and free your soul from the ethernal suffering.", width/2, height/2, 890, 390);
    }
}

public void winMenu()
{
    gameMusic.stop();
    strokeWeight(2);
    imageMode(CENTER);
    background(mainMenuBackground);
    fill(0xFF00FF00);
    rectMode(CENTER);
    rect(mainmenuButtonPosition.x, mainmenuButtonPosition.y, 180, 50, 5);
    fill(0xFFFF0000);
    rect(quitButtonPosition.x, quitButtonPosition.y, 180, 50, 5);
    textFont(titleFont, 96);
    fill(0);
    textAlign(CENTER, CENTER);
    text("You escaped!\nYour soul is now free!", width/2, 150);
    fill(0xFFFF0000);
    text("You escaped!\nYour soul is now free!", width/2-4, 146);
    textFont(baseFont, 24);
    fill(0);
    text("Main Menu", mainmenuButtonPosition.x, mainmenuButtonPosition.y);
    text("Quit", quitButtonPosition.x, quitButtonPosition.y);
}

public void storyScreen()
{
    background(mainMenuBackground);
    rectMode(CENTER);
    strokeWeight(2);
    fill(128, 128, 128, 225);
    rect(width/2, height/2, 760, 400);
    textAlign(CENTER, CENTER);
    textFont(baseFont, 24);
    fill(0);
    text(introText[0], width/2, height/2, 740, 400);
}

public void deathMenu()
{
    background(deathBackground);
    textAlign(CENTER, CENTER);
    textFont(baseFont, 24);
    fill(255);
    text("Click to return to main menu", width/2, 580);
}

public void resetGame()
{
    sceneManager.loadScene(basementScene);
    basementScene.background = basementScatteredBackground;
    basementScene.addMoveButton(new PVector(455, 225), new PVector(64, 64), pipeHint, pipeHintPaper, notePickup);
    storageScene.addMoveButton(new PVector(285, 354), new PVector(64, 64), jarHint, jarHintPaper, notePickup);
    correctJarOrder = new Jar[jarCount];
    randomJarOrder = new Jar[jarCount];
    for(int i = 0; i < jarCount; i++) correctJarOrder[i] = new Jar(new PVector(200, 200), i, jarImages[i]);
    for(int i = 0; i < jarCount; i++) scrambleJars(i);
    selectedJar = null;
    for(int i = 0; i < pipeHolders.size(); i++)
    {
        PipeHolder pH = pipeHolders.get(i);
        switch(pipeLayouts[usedLayout][i])
        {
            case 0:
                pH.heldPipe = new CornerPipe(pH.position, (int)(random(0, 4)), i, cornerPipeImages);
                break;
            case 1:
                pH.heldPipe = new StraightPipe(pH.position, (int)(random(4, 6)), i, straightPipeImages);
                break;
        }
    }
    isPipeGameOver = false;
    isJarGameOver = false;
    cake = new Cake(new PVector(359, 250), new PVector(64, 64), bowl, kitchenScene.sceneButtons);
    kitchenScene.sceneButtons.add(cake);
    cake.itemsNeeded = cookItems;
    hideIngredients();
}

public boolean isDelayOver()
{
    return millis() >= targetMilliseconds;
}

public void setupDelay(int secondsToDelay)
{
    targetMilliseconds = millis() + secondsToDelay * 1000;
    isDelaySet = true;
}

public void startGameplayTimer()
{
    gameEndMilliseconds = millis() + gameplaySeconds * 1000;
    isGameplayTimerSet = true;
}

public void hideIngredients()
{
    IntList randomIndexes = new IntList();
    for(int i = 0; i < 5; i++) randomIndexes.append(i);
    randomIndexes.shuffle();
    basementScene.addItemButton(new PVector(957, 374), new PVector(64, 64),cookItems[randomIndexes.get(0)], false);
    kitchenScene.addItemButton(new PVector(373, 67), new PVector(64, 64),cookItems[randomIndexes.get(1)], false);
    storageScene.addItemButton(new PVector(676, 371), new PVector(64, 64),cookItems[randomIndexes.get(2)], false);
    storageScene.addItemButton(new PVector(365, 96), new PVector(64, 64),cookItems[randomIndexes.get(3)], false);
    hallwayScene.addItemButton(new PVector(50, 440), new PVector(64, 64),cookItems[randomIndexes.get(4)], false);
}
enum ButtonType{Item, Move}

class Button
{
    PVector buttonPosition;
    PVector buttonSize;

    public void drawButton()
    {
        strokeWeight(0);
        rectMode(CENTER);
        fill(255, 255, 255, 0);
        rect(buttonPosition.x, buttonPosition.y, buttonSize.x, buttonSize.y);
    }

    public void buttonAction()
    {}
}
class Cake extends Button
{
    int itemsAdded = 0;
    Item[] itemsNeeded = new Item[5];
    PImage cakeIcon;
    ArrayList removeButtonFrom;

    Cake(PVector pPos, PVector pSize, PImage pIcon, ArrayList pArray)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        cakeIcon = pIcon;
        removeButtonFrom = pArray;
    }

    public void buttonAction()
    {
        int foundAnyItem = 0;
        if(itemsAdded <= 4)
        {
            for(int i = 0; i < 5; i++)
            {
                boolean found = inventory.isInInventory(itemsNeeded[i], true);
                if(found) 
                {
                    itemsAdded++; 
                    foundAnyItem++;
                    break; 
                }
            }
            if(foundAnyItem == 0) {missingIngredients.toggleRender();}
        }
        else
        {
            if(inventory.allowItemPickup) inventory.heldItems.add(fullBowl);
            else kitchenScene.addItemButton(new PVector(480, 265), new PVector(64, 64), fullBowl, false);
            removeButtonFrom.remove(this);
        }
    }

    public void drawButton()
    {
        fill(255, 255, 255, 255);
        PImage imageToDraw = (itemsAdded == 5) ? fullBowlImage : cakeIcon;
        if(mouseX < buttonPosition.x + buttonSize.x/2 && mouseX > buttonPosition.x - buttonSize.x/2 && mouseY < buttonPosition.y + buttonSize.y/2 && mouseY > buttonPosition.y - buttonSize.y/2) noTint();
        else tint(16, 16, 16, 255);
        image(imageToDraw, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, 64, 64);
        noTint();
    }
}
class CornerPipe extends Pipe
{
    PImage[] sprites = new PImage[4];

    CornerPipe(PVector pHolderPos, int pRotation, int pArrayIndex, PImage[] pImageArray)
    {
        pipeRotationNum = pRotation;
        holderPosition = pHolderPos;
        arrayIndex = pArrayIndex;
        sprites = pImageArray;
        switch(pRotation)
        {
            case 0:
                pipeRotation = PipeState.SouthEast;
                break;
            case 1:
                pipeRotation = PipeState.SouthWest;
                break;
            case 2:
                pipeRotation = PipeState.NorthWest;
                break;
            case 3:
                pipeRotation = PipeState.NorthEast;
                break;
        }
    }

    public void drawPipe()
    {
        fill(0);
        switch (pipeRotation) 
        {
            case SouthEast:
                spriteToDraw = sprites[0];
                break;
            case SouthWest:
                spriteToDraw = sprites[1];
                break;
            case NorthEast:
                spriteToDraw = sprites[2];
                break;
            case NorthWest:
                spriteToDraw = sprites[3];
                break;
        }
        image(spriteToDraw, holderPosition.x - gridBoxSize / 2, holderPosition.y - gridBoxSize / 2, gridBoxSize, gridBoxSize);
    }

    public void rotatePipe()
    {
        pipeSound.play();
        if(pipeRotationNum < 3) pipeRotationNum++;
        else pipeRotationNum = 0;
        switch(pipeRotationNum)
        {
            case 0:
                pipeRotation = PipeState.SouthEast;
                break;
            case 1:
                pipeRotation = PipeState.SouthWest;
                break;
            case 2:
                pipeRotation = PipeState.NorthWest;
                break;
            case 3:
                pipeRotation = PipeState.NorthEast;
                break;
        }
    }
}
class ExitButton extends Button
{
    PImage buttonIcon;

    ExitButton(PVector pPos, PVector pSize, PImage pIcon)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        buttonIcon = pIcon;
    }

    public void drawButton()
    {
        fill(255, 255, 255, 255);
        image(buttonIcon, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, 64, 64);
    }

    public void buttonAction()
    {
        boolean exit = allowExit(false);
        if(exit) 
        {
            mainDoorUnlock.play();
            allowExit(true);
            gameState = GameState.WinMenu;
            isWinMenu = true;
        }
        else
        {
            keysMissing.toggleRender();
            lockedDoor.play();
        } 
    }

    public boolean allowExit(boolean removeKeys)
    {
        boolean isPipeKey = false;
        boolean isCookKey = false;
        boolean isJarKey = false;
        if(inventory.isInInventory(pipeKey, removeKeys)) {isPipeKey = true;}
        if(inventory.isInInventory(cookKey, removeKeys)) {isCookKey = true;}
        if(inventory.isInInventory(jarKey, removeKeys)) {isJarKey = true;}
        return isPipeKey && isCookKey && isJarKey;
    }
}
class Inventory
{
    ArrayList<Item> heldItems = new ArrayList<Item>();
    int slotCount;
    int boxSize;
    int yOffset;
    int xPos = 10;
    boolean allowItemPickup;

    Inventory(int pSlotCount, int pBoxSize, int pYOffset)
    {
        slotCount = pSlotCount;
        boxSize = pBoxSize;
        yOffset = pYOffset;
    }

    public void drawInventory()
    {
        allowItemPickup = (heldItems.size() < slotCount) ? true : false;
        strokeWeight(0);
        fill(128, 128, 128, 225);
        for(int i = 0; i < slotCount; i++)
        {
            int yPos = (i * boxSize) + yOffset * (i + 1);
            imageMode(CORNER);
            image(inventoryImage, xPos, yPos, boxSize, boxSize);
        }
        int loopCount = min(heldItems.size(), slotCount);
        for(int i = 0; i < loopCount; i++)
        {
            Item item = heldItems.get(i);
            int yPos = (i * boxSize) + yOffset * (i + 1);
            image(item.itemImage, xPos+8, yPos+8, boxSize-16, boxSize-16);
        }
    }

    public boolean isInInventory(Item item, boolean removeFound)
    {
        boolean foundItem = false;
        for(int i = 0; i < heldItems.size(); i++)
        {
            if(heldItems.get(i) == item)
            {
                if(removeFound) heldItems.remove(i);
                foundItem = true;
                break;
            }
        }
        return foundItem;
    }
}
class Item
{
    PImage itemImage;

    Item(PImage pitemImage)
    {
        itemImage = pitemImage;
    }
}
class ItemButton extends Button
{
    Item buttonItem;
    ArrayList removeButtonFrom;
    boolean isKey;

    ItemButton(PVector pPos, PVector pSize, Item pItem, ArrayList pArray, boolean pIsKey)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        buttonItem = pItem;
        removeButtonFrom = pArray;
        isKey = pIsKey;
    }

    public void buttonAction()
    {
        if(inventory.allowItemPickup)
        {
            inventory.heldItems.add(buttonItem);
            removeButtonFrom.remove(this);
            SoundFile sf = (isKey) ? keysPickup : grabObject;
            sf.play();
        }
        else
        {
            fullInventoryNotification.toggleRender();
        }
    }

    public void drawButton()
    {
        strokeWeight(12);
        fill(255, 255, 255, 255);
        if(mouseX < buttonPosition.x + buttonSize.x/2 && mouseX > buttonPosition.x - buttonSize.x/2 && mouseY < buttonPosition.y + buttonSize.y/2 && mouseY > buttonPosition.y - buttonSize.y/2) noTint();
        else tint(16, 16, 16, 255);
        image(buttonItem.itemImage, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, buttonSize.x, buttonSize.y);
        noTint();
    }
}
class Jar
{
    int indexInArray;
    int jarPosition;
    PVector jarSize;
    PVector position;
    PImage jarIcon;
    boolean isJarSelected;
    boolean isInCorrectSpot;
    Jar(PVector pSize, int pIndex, PImage pIcon)
    {
        jarSize = pSize;
        indexInArray = pIndex;
        jarIcon = pIcon;
        position = new PVector(0, 0);
    }

    public void drawJar()
    {
        position.x = jarPosition * 100 + (jarPosition * 50) + 200;
        position.y = 415 - jarSize.y/2;
        fill(255, 255, 255, 255);
        imageMode(CENTER);
        image(jarIcon, position.x, position.y, jarSize.x, jarSize.y);
        fill(0);
        if(jarPosition == indexInArray) isInCorrectSpot = true;
        else isInCorrectSpot = false;
    }

    public boolean isOverJar()
    {
        return mouseX < position.x + jarSize.x/2 && mouseX > position.x - jarSize.x/2 && mouseY < position.y + jarSize.y/2 && mouseY > position.y - jarSize.y/2;
    }
}
class JarButton
{
    PImage arrow;
    PVector position;
    JarButton(PImage pImage, PVector pPos)
    {
        arrow = pImage;
        position = pPos;
    }

    public void moveRight(int toMoveIndex)
    {
        if(toMoveIndex == 4)
        {
            println("cannot move");
        }
        else
        {
            jarSlides[(int)(random(0, 2))].play();
            Jar jar1 = randomJarOrder[toMoveIndex];
            Jar jar2 = randomJarOrder[toMoveIndex + 1];
            randomJarOrder[toMoveIndex] = jar2;
            randomJarOrder[toMoveIndex + 1] = jar1;
            jar1.jarPosition = toMoveIndex + 1;
            jar2.jarPosition = toMoveIndex;
        }
    }

    public void moveLeft(int toMoveIndex)
    {
        if(toMoveIndex == 0)
        {
            println("cannot move");
        }
        else
        {
            jarSlides[(int)(random(0, 2))].play();
            Jar jar1 = randomJarOrder[toMoveIndex];
            Jar jar2 = randomJarOrder[toMoveIndex - 1];
            randomJarOrder[toMoveIndex] = jar2;
            randomJarOrder[toMoveIndex - 1] = jar1;
            jar1.jarPosition = toMoveIndex - 1;
            jar2.jarPosition = toMoveIndex;
        }
    }

    public void drawArrow()
    {
        imageMode(CORNER);
        image(arrow, position.x - 32, position.y - 32, 64, 64);
    }

    public boolean isOverJarButton()
    {
        return mouseX < position.x + 32 && mouseX > position.x - 32 && mouseY < position.y + 32 && mouseY > position.y - 32;
    }
}
class MoveButton extends Button
{
    GameState nextGameState;
    ButtonType buttonType;
    Scene sceneToMove;
    PImage buttonIcon;
    Item requieredItem;
    SoundFile transitionSound;

    MoveButton(PVector pPos, PVector pSize, Scene pScene)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
    }

    MoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
        buttonIcon = pIcon;
    }

    MoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon, Item pItem)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
        buttonIcon = pIcon;
        requieredItem = pItem;
    }

    MoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon, SoundFile pTransition)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
        buttonIcon = pIcon;
        transitionSound = pTransition;
    }

    MoveButton(PVector pPos, PVector pSize, PImage pIcon, GameState pGameState)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        buttonIcon = pIcon;
        nextGameState = pGameState;
    }

    public void drawButton()
    {
        fill(255, 255, 255, 255);
        imageMode(CORNER);
        if(buttonIcon != null) image(buttonIcon, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, 64, 64);
    }

    public void buttonAction()
    {
        if(requieredItem != null)
        {
            if(inventory.isInInventory(requieredItem, true))
            {
                playTransitionSound();
                sceneManager.loadScene(sceneToMove);
            }
            else
            {
                println("missing item");
            }
        }
        else if(nextGameState != null)
        {
            gameState = nextGameState;
        }
        else
        {
            if(transitionSound != null)
            {
                transitionSound.play();
                sceneManager.loadScene(sceneToMove);
            }
            else
            {
                playTransitionSound();
                sceneManager.loadScene(sceneToMove);
            }
        }
    }

    public void playTransitionSound()
    {
        roomTransitions[(int)(random(0,3))].play();
    }
}
class Oven extends Button
{
    PImage ovenIcon;

    Oven(PVector pPos, PVector pSize, PImage pIcon)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        ovenIcon = pIcon;
    }

    public void drawButton()
    {
        fill(255, 255, 255, 255);
        image(ovenIcon, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, buttonSize.x, buttonSize.y);
    }

    public void buttonAction()
    {
        if(inventory.isInInventory(fullBowl, true))
        {
            cookKeyFound.toggleRender();
            inventory.heldItems.add(cookKey);
        }
        else missingBowl.toggleRender();
    }
}
enum PipeState{SouthEast, SouthWest, NorthEast, NorthWest, UpDown, LeftRight};
class Pipe
{
    PImage spriteToDraw;
    PipeState pipeRotation;
    PVector holderPosition;
    int pipeRotationNum;
    int arrayIndex;

    public void rotatePipe()
    {}

    public void drawPipe()
    {}
}
class PipeHolder
{
    PVector position;
    Pipe heldPipe;

    PipeHolder(PVector pPos)
    {
        position = pPos;
    }

    public void drawHolder()
    {
        rectMode(CENTER);
        strokeWeight(0);
        fill(255, 255, 255, 0);
        rect(position.x, position.y, gridBoxSize, gridBoxSize);
        heldPipe.drawPipe();
    }

    public boolean isOverHeldPipe()
    {
        return mouseX < position.x + gridBoxSize/2 && mouseX > position.x - gridBoxSize/2 && mouseY < position.y + gridBoxSize/2 && mouseY > position.y - gridBoxSize/2;
    }
}
class Scene
{
    PImage background;
    ArrayList<Button> sceneButtons = new ArrayList<Button>();
    ArrayList<TextBox> sceneTexts = new ArrayList<TextBox>();
    boolean isTextBeingRendered = false;
    boolean isIntermediateScreen = false;
    Scene nextScene;
    GameState nextGamestate;

    Scene(PImage pBackground)
    {
        background = pBackground;
    }

    Scene(PImage pBackground, boolean pIntermediate, Scene pNextScene)
    {
        background = pBackground;
        isIntermediateScreen = pIntermediate;
        nextScene = pNextScene;
    }

    Scene(PImage pBackground, boolean pIntermediate, GameState pNextState)
    {
        background = pBackground;
        isIntermediateScreen = pIntermediate;
        nextGamestate = pNextState;
    }

    //Draws the scene and the buttons in the scene
    public void drawScene()
    {
        imageMode(CORNER);
        image(background, 0, 0, width, height);
        for(Button button : sceneButtons)
        {
            button.drawButton();
        }
        for(TextBox textBox : sceneTexts)
        {
            if(textBox.renderText) {textBox.drawTextBox();}
        }
    }

    //Basic move button
    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene));
    }

    //Move button with sound
    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon, SoundFile pTransition)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene, pIcon, pTransition));
    }

    //Move button with icon
    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene, pIcon));
    }

    //Move button with Item condition
    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon, Item pItem)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene, pIcon, pItem));
    }

    //Move button with GameState change - use when changing to minigames
    public void addMoveButton(PVector pPos, PVector pSize, PImage pIcon, GameState pGameState)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pIcon, pGameState));
    }

    //Basic item button
    public void addItemButton(PVector pPos, PVector pSize, Item pItem, boolean pIsKey)
    {
        sceneButtons.add(new ItemButton(pPos, pSize, pItem, sceneButtons, pIsKey));
    }

    //Basic text button
    public void addTextButton(PVector pPos, PVector pSize, PImage pIcon, TextBox pText)
    {
        sceneButtons.add(new TextButton(pPos, pSize, pIcon, pText));
    }

    //Add mansion exit button
    public void addExitButton(PVector pPos, PVector pSize, PImage pIcon)
    {
        sceneButtons.add(new ExitButton(pPos, pSize, pIcon));
    }

    //Basic text box
    public TextBox createTextBox(String pText)
    {
        TextBox tempTextBox = new TextBox(pText, this);
        sceneTexts.add(tempTextBox);
        return tempTextBox;
    }

    //Big text box
    public TextBox createTextBox(String pText, boolean pBigText, Scene pNextScene)
    {
        TextBox tempTextBox = new TextBox(pText, this, pBigText, pNextScene);
        sceneTexts.add(tempTextBox);
        return tempTextBox;
    }

    //Checks for collision on all buttons in the Scene
    public void checkButtonCollision()
    {
        if(isTextBeingRendered) 
        {
            isTextBeingRendered = false;
            for(TextBox textBox : sceneTexts)
            {
                if(textBox.renderText)
                {
                    textBox.toggleRender();
                    break;
                }
            }
        }
        else if(isIntermediateScreen) 
        {
            if(nextScene != null) sceneManager.loadScene(nextScene);
            else gameState = nextGamestate;   
        }
        else 
        {
            for(Button button : sceneButtons)
            {
                if(mouseX < button.buttonPosition.x + button.buttonSize.x/2 && mouseX > button.buttonPosition.x - button.buttonSize.x/2 && mouseY < button.buttonPosition.y + button.buttonSize.y/2 && mouseY > button.buttonPosition.y - button.buttonSize.y/2)
                {
                    button.buttonAction();
                    break;
                }
            }
        }
    }
}
class SceneManager
{
    Scene currentScene;

    public void draw()
    {
        currentScene.drawScene();
    }

    public void loadScene(Scene newScene)
    {
        if(currentScene.sceneTexts.size() > 0)
        {
            currentScene.sceneTexts.remove(currentScene.sceneTexts.size()-1);
        }
        fullInventoryNotification.parentScene = newScene;
        newScene.sceneTexts.add(fullInventoryNotification);
        currentScene = newScene;
    }

    public void mouseClick()
    {
        currentScene.checkButtonCollision();
    }
}
class StraightPipe extends Pipe
{
    PImage[] sprites = new PImage[2];

    StraightPipe(PVector pHolderPos, int pRotation, int pArrayIndex, PImage[] pImageArray)
    {
        pipeRotationNum = pRotation;
        holderPosition = pHolderPos;
        arrayIndex = pArrayIndex;
        sprites = pImageArray;
        switch(pRotation)
        {
            case 4:
                pipeRotation = PipeState.UpDown;
                break;
            case 5:
                pipeRotation = PipeState.LeftRight;
                break;
        }
    }

    public void drawPipe()
    {
        fill(255, 255, 255, 0);
        switch(pipeRotation)
        {
            case UpDown:
                spriteToDraw = sprites[0];
                break;
            case LeftRight:
                spriteToDraw = sprites[1];
                break;
        }
        image(spriteToDraw, holderPosition.x - gridBoxSize / 2, holderPosition.y - gridBoxSize / 2, gridBoxSize, gridBoxSize);
    }

    public void rotatePipe()
    {
        pipeSound.play();
        switch(pipeRotationNum)
        {
            case 4:
                pipeRotationNum = 5;
                pipeRotation = PipeState.LeftRight;
                break;
            case 5:
                pipeRotationNum = 4;
                pipeRotation = PipeState.UpDown;
                break;
        }
    }
}
class TextBox
{
    String bodyText;
    boolean renderText;
    boolean bigText = false;
    Scene parentScene;
    Scene nextScene;

    TextBox(String pText, Scene pScene)
    {
        bodyText = pText;
        parentScene = pScene;
    }

    TextBox(String pText, Scene pScene, boolean pBigText, Scene pNextScene)
    {
        bodyText = pText;
        parentScene = pScene;
        bigText = pBigText;
        nextScene = pNextScene;
    }

    public void toggleRender()
    {
        renderText = !renderText;
        parentScene.isTextBeingRendered = renderText;
        if(bigText && !renderText)
        {
            sceneManager.loadScene(nextScene);
        }
    }

    public void drawTextBox()
    {
        rectMode(CENTER);
        strokeWeight(2);
        fill(128, 128, 128, 225);
        if(!bigText)
        {
            rect(width/2, 550, width - 40, 80);
            textAlign(LEFT, TOP);
            textFont(baseFont, 20);
            fill(0);
            text(bodyText, width/2, 550, width - 60, 70);
        }
        else
        {
            rect(width/2, height/2, 760, 400);
            textAlign(CENTER, CENTER);
            textFont(baseFont, 24);
            fill(0);
            text(bodyText, width/2, height/2, 740, 400);
        }
    }
}
class TextButton extends Button
{
    PImage buttonIcon;
    TextBox textBoxToRender; 

    TextButton(PVector pPos, PVector pSize, PImage pIcon, TextBox pTextBox)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        buttonIcon = pIcon;
        textBoxToRender = pTextBox;
    }

    public void buttonAction()
    {
        textBoxToRender.toggleRender();
    }

    public void drawButton()
    {
        strokeWeight(12);
        fill(255, 255, 255, 255);
        image(buttonIcon, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, buttonSize.x, buttonSize.y);
    }
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "first_contact" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
