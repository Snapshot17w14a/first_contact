/* autogenerated by Processing revision 1293 on 2023-11-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class first_contact extends PApplet {

enum GameState{Scenes, PipeGame, JarGame, CookGame, MainMenu};

//Framework Variables
GameState gameState = GameState.Scenes;
SceneManager sceneManager;
Scene currentScene;
Scene initialScene;
Scene room1Scene;
PImage img1;
PImage img2;
PImage magnifier;
Inventory inventory;
Item glass;

//Pipe Game Variables
int gridWidth = 5;
int gridHeight = 3;
static int gridBoxSize = 133;
ArrayList<PipeHolder> pipeHolders = new ArrayList<PipeHolder>();
PImage background;
PImage straightPipeUpDown;
PImage straightPipeLeftRight;
PImage[] straightPipeImages = new PImage[2];
PImage[] cornerPipeImages = new PImage[4];

//Universal Variables
boolean allowMouseClick = true;

public void setup()
{
    /* size commented out by preprocessor */;
    img1 = loadImage("Images/basement.png");
    img2 = loadImage("Factory1.png");
    magnifier = loadImage("magnifier.png");
    sceneManager = new SceneManager();
    inventory = new Inventory(3, 100, 10);
    glass = new Item(magnifier);

    room1Scene = new Scene(img2);
    initialScene = new Scene(img1);

    room1Scene.addMoveButton(new PVector(200, 400), new PVector(64, 64), initialScene, magnifier, glass);
    room1Scene.addMoveButton(new PVector(500, 400), new PVector(64, 64), magnifier, GameState.PipeGame);
    initialScene.addMoveButton(new PVector(400, 600), new PVector(100, 120), room1Scene);

    room1Scene.addItemButton(new PVector(400, 200), new PVector(32, 32), glass);
    room1Scene.addItemButton(new PVector(300, 400), new PVector(32, 32), glass);
    room1Scene.addItemButton(new PVector(600, 100), new PVector(32, 32), glass);
    room1Scene.addItemButton(new PVector(700, 500), new PVector(32, 32), glass);
    room1Scene.addItemButton(new PVector(771, 661), new PVector(32, 32), glass);

    sceneManager.loadScene(initialScene);

    //Pipe Game Images
    background = loadImage("pipeBackground.png");
    straightPipeImages[0] = loadImage("Pipe_Straight_UpDown.png");
    straightPipeImages[1] = loadImage("Pipe_Straight_LeftRight.png");
    cornerPipeImages[0] = loadImage("Pipe_Corner_SouthEast.png");
    cornerPipeImages[1] = loadImage("Pipe_Corner_SouthWest.png");
    cornerPipeImages[2] = loadImage("Pipe_Corner_NorthEast.png");
    cornerPipeImages[3] = loadImage("Pipe_Corner_NorthWest.png");

    //Pipe Game Init
    for(int rows = 0; rows < gridHeight; rows++)
    {
        int yPos = 170 + (gridBoxSize * rows);
        for(int column = 0; column < gridWidth; column++)
        {
            int xPos = 217 + (gridBoxSize * column);
            pipeHolders.add(new PipeHolder(new PVector(xPos, yPos)));
        }
    }
    PipeHolder ph = pipeHolders.get(0);
    for(int i = 0; i < pipeHolders.size(); i++)
    {
        PipeHolder pH = pipeHolders.get(i);
        int pipeType = (int)(random(0, 2));
        switch(pipeType)
        {
            case 0:
                pH.heldPipe = new CornerPipe(pH.position, (int)(random(0, 4)), i, cornerPipeImages);
                break;
            case 1:
                pH.heldPipe = new StraightPipe(pH.position, (int)(random(4, 6)), i, straightPipeImages);
                break;
        }
    }
}

public void draw() 
{
    background(0);
    if(gameState == GameState.Scenes) {drawScenes();}
    if(gameState == GameState.PipeGame) {pipeGame();}
}

public void mousePressed() 
{
    if(allowMouseClick) sceneManager.mouseClick();
    if(allowMouseClick)
    {
        allowMouseClick = false;
        for(PipeHolder pH : pipeHolders)
        {
            if(pH.isOverHeldPipe())
            {
                pH.heldPipe.rotatePipe();
            }
            
        }
    }
    allowMouseClick = false;
}

public void mouseReleased()
{
    allowMouseClick = true;
}

public void drawScenes()
{
    sceneManager.draw();
    inventory.drawInventory();
}

public void pipeGame()
{
    background(0);
    image(background, 0, 0, width, height);
    for(PipeHolder pHolder : pipeHolders)
    {
        pHolder.drawHolder();
    }
}
enum ButtonType{Item, Move}

class Button
{
    PVector buttonPosition;
    PVector buttonSize;

    public void drawButton()
    {
        strokeWeight(0);
        rectMode(CENTER);
        fill(255, 255, 255, 0);
        rect(buttonPosition.x, buttonPosition.y, buttonSize.x, buttonSize.y);
    }

    public void buttonAction()
    {}
}
class CornerPipe extends Pipe
{
    PImage[] sprites = new PImage[4];

    CornerPipe(PVector pHolderPos, int pRotation, int pArrayIndex, PImage[] pImageArray)
    {
        pipeRotationNum = pRotation;
        holderPosition = pHolderPos;
        arrayIndex = pArrayIndex;
        sprites = pImageArray;
        switch(pRotation)
        {
            case 0:
                pipeRotation = PipeState.SouthEast;
                break;
            case 1:
                pipeRotation = PipeState.SouthWest;
                break;
            case 2:
                pipeRotation = PipeState.NorthWest;
                break;
            case 3:
                pipeRotation = PipeState.NorthEast;
                break;
        }
    }

    public void drawPipe()
    {
        fill(0);
        switch (pipeRotation) 
        {
            case SouthEast:
                spriteToDraw = sprites[0];
                break;
            case SouthWest:
                spriteToDraw = sprites[1];
                break;
            case NorthEast:
                spriteToDraw = sprites[2];
                break;
            case NorthWest:
                spriteToDraw = sprites[3];
                break;
        }
        image(spriteToDraw, holderPosition.x - gridBoxSize / 2, holderPosition.y - gridBoxSize / 2, gridBoxSize, gridBoxSize);
    }

    public void rotatePipe()
    {
        if(pipeRotationNum < 3) pipeRotationNum++;
        else pipeRotationNum = 0;
        switch(pipeRotationNum)
        {
            case 0:
                pipeRotation = PipeState.SouthEast;
                break;
            case 1:
                pipeRotation = PipeState.SouthWest;
                break;
            case 2:
                pipeRotation = PipeState.NorthWest;
                break;
            case 3:
                pipeRotation = PipeState.NorthEast;
                break;
        }
    }
}

class Inventory
{
    ArrayList<Item> heldItems = new ArrayList<Item>();
    int slotCount;
    int boxSize;
    int yOffset;
    int xPos = 10;
    boolean allowItemPickup;

    Inventory(int pSlotCount, int pBoxSize, int pYOffset)
    {
        slotCount = pSlotCount;
        boxSize = pBoxSize;
        yOffset = pYOffset;
    }

    public void drawInventory()
    {
        allowItemPickup = (heldItems.size() < slotCount) ? true : false;
        strokeWeight(0);
        fill(255, 255, 255, 255);
        for(int i = 0; i < slotCount; i++)
        {
            int yPos = (i * boxSize) + yOffset * (i + 1);
            rectMode(CORNER);
            rect(xPos, yPos, boxSize, boxSize);
        }
        int loopCount = min(heldItems.size(), slotCount);
        for(int i = 0; i < loopCount; i++)
        {
            Item item = heldItems.get(i);
            int yPos = (i * boxSize) + yOffset * (i + 1);
            image(item.itemImage, xPos, yPos, boxSize, boxSize);
        }
    }

    public boolean isInInventory(Item item, boolean removeFound)
    {
        boolean foundItem = false;
        for(int i = 0; i < heldItems.size(); i++)
        {
            if(heldItems.get(i) == item)
            {
                if(removeFound)
                {
                    heldItems.remove(i);
                }
                foundItem = true;
                break;
            }
        }
        return foundItem;
    }
}
class Item
{
    PImage itemImage;

    Item(PImage pitemImage)
    {
        itemImage = pitemImage;
    }
}
class ItemButton extends Button
{
    Item buttonItem;
    ArrayList removeButtonFrom;

    ItemButton(PVector pPos, PVector pSize, Item pItem, ArrayList pArray)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        buttonItem = pItem;
        removeButtonFrom = pArray;
    }

    public void buttonAction()
    {
        if(inventory.allowItemPickup)
        {
            inventory.heldItems.add(buttonItem);
            removeButtonFrom.remove(this);
        }
        else
        {
            println("inv full");
        }
    }

    public void drawButton()
    {
        strokeWeight(12);
        fill(255, 255, 255, 255);
        image(buttonItem.itemImage, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, buttonSize.x, buttonSize.y);
    }
}
class MoveButton extends Button
{
    GameState nextGameState;
    ButtonType buttonType;
    Scene sceneToMove;
    PImage buttonIcon;
    Item requieredItem;

    MoveButton(PVector pPos, PVector pSize, Scene pScene)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
    }

    MoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
        buttonIcon = pIcon;
    }

    MoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon, Item pItem)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        sceneToMove = pScene;
        buttonIcon = pIcon;
        requieredItem = pItem;
    }

    MoveButton(PVector pPos, PVector pSize, PImage pIcon, GameState pGameState)
    {
        buttonPosition = pPos;
        buttonSize = pSize;
        buttonIcon = pIcon;
        nextGameState = pGameState;
    }

    public void drawButton()
    {
        strokeWeight(0);
        rectMode(CENTER);
        fill(255, 255, 255, 0);
        rect(buttonPosition.x, buttonPosition.y, buttonSize.x, buttonSize.y);
        fill(255, 255, 255, 255);
        if(buttonIcon != null) image(buttonIcon, buttonPosition.x - buttonSize.x/2, buttonPosition.y - buttonSize.y/2, 64, 64);
    }

    public void buttonAction()
    {
        if(requieredItem != null)
        {
            if(inventory.isInInventory(requieredItem, true))
            {
                sceneManager.loadScene(sceneToMove);
            }
            else
            {
                println("missing item");
            }
        }
        else if(nextGameState != null)
        {
            gameState = nextGameState;
        }
        else
        {
            sceneManager.loadScene(sceneToMove);
        }
    }
}
enum PipeState{SouthEast, SouthWest, NorthEast, NorthWest, UpDown, LeftRight};
class Pipe
{
    PImage spriteToDraw;
    PipeState pipeRotation;
    PVector holderPosition;
    int pipeRotationNum;
    int arrayIndex;

    public void rotatePipe()
    {}

    public void drawPipe()
    {}
}
class PipeHolder
{
    PVector position;
    Pipe heldPipe;

    PipeHolder(PVector pPos)
    {
        position = pPos;
    }

    public void drawHolder()
    {
        rectMode(CENTER);
        fill(255, 255, 255, 0);
        rect(position.x, position.y, gridBoxSize, gridBoxSize);
        heldPipe.drawPipe();
    }

    public boolean isOverHeldPipe()
    {
        return mouseX < position.x + gridBoxSize/2 && mouseX > position.x - gridBoxSize/2 && mouseY < position.y + gridBoxSize/2 && mouseY > position.y - gridBoxSize/2;
    }
}
class Scene
{
    PImage background;
    ArrayList<Button> sceneButtons = new ArrayList<Button>();

    Scene(PImage pBackground)
    {
        background = pBackground;
    }

    public void drawScene()
    {
        image(background, 0, 0, width, height);
        for(Button button : sceneButtons)
        {
            button.drawButton();
        }
    }

    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene));
    }

    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene, pIcon));
    }

    public void addMoveButton(PVector pPos, PVector pSize, Scene pScene, PImage pIcon, Item pItem)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pScene, pIcon, pItem));
    }

    public void addMoveButton(PVector pPos, PVector pSize, PImage pIcon, GameState pGameState)
    {
        sceneButtons.add(new MoveButton(pPos, pSize, pIcon, pGameState));
    }

    public void addItemButton(PVector pPos, PVector pSize, Item pItem)
    {
        sceneButtons.add(new ItemButton(pPos, pSize, pItem, sceneButtons));
    }

    public void checkButtonCollision()
    {
        for(Button button : sceneButtons)
        {
            if(mouseX < button.buttonPosition.x + button.buttonSize.x/2 && mouseX > button.buttonPosition.x - button.buttonSize.x/2 && mouseY < button.buttonPosition.y + button.buttonSize.y/2 && mouseY > button.buttonPosition.y - button.buttonSize.y/2)
            {
                button.buttonAction();
                break;
            }
        }
    }
}
class SceneManager
{
    Scene currentScene;

    public void draw()
    {
        currentScene.drawScene();
    }

    public void loadScene(Scene newScene)
    {
        currentScene = newScene;
    }

    public void mouseClick()
    {
        currentScene.checkButtonCollision();
    }
}
class StraightPipe extends Pipe
{
    PImage[] sprites = new PImage[2];

    StraightPipe(PVector pHolderPos, int pRotation, int pArrayIndex, PImage[] pImageArray)
    {
        pipeRotationNum = pRotation;
        holderPosition = pHolderPos;
        arrayIndex = pArrayIndex;
        sprites = pImageArray;
        switch(pRotation)
        {
            case 4:
                pipeRotation = PipeState.UpDown;
                break;
            case 5:
                pipeRotation = PipeState.LeftRight;
                break;
        }
    }

    public void drawPipe()
    {
        fill(255, 255, 255, 0);
        switch(pipeRotation)
        {
            case UpDown:
                spriteToDraw = sprites[0];
                break;
            case LeftRight:
                spriteToDraw = sprites[1];
                break;
        }
        image(spriteToDraw, holderPosition.x - gridBoxSize / 2, holderPosition.y - gridBoxSize / 2, gridBoxSize, gridBoxSize);
    }

    public void rotatePipe()
    {
        switch(pipeRotationNum)
        {
            case 4:
                pipeRotationNum = 5;
                pipeRotation = PipeState.LeftRight;
                break;
            case 5:
                pipeRotationNum = 4;
                pipeRotation = PipeState.UpDown;
                break;
        }
    }
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "first_contact" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
